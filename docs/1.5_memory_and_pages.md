# S memory management

## 用户可用的内存（无 SBI）

我们可以假装放一个很大的数组，并宣称它就是我们的用户可用的内存。我们只需要在链接脚本里指定这个内存应当处在的位置。

我们在链接脚本中使用 ``PROVIDE`` 命令标记内核占用的内存的末段，并将紧随其后的若干「页」指定为用户可用的内存。

一方面，我们定义变量：

``` C
extern char pmem_base[];
```

然后，我们在链接脚本的 ``SECTION`` 部份的末段指定：

```
  PROVIDE(pmem_base = .)
```

这样将对应的地址导出成了符号。

当然，事实上，在这里我们还没有划分出真正的页。所以我们只是简单地约定一个物理内存的上限：

``` C
#define PMEM_END (PMEM_START + 128 * 1024 * 1024)
```

事实上这就是我们一开始在编译选项中定义的 ``128 mb`` 内存。也就是说，我们将所有除了内核占用的几个段以外的内存都划成用户能访问的物理页。

然后用一个链表维护这个物理页池即可。

同时，我们设计函数 ``palloc`` 和 ``pfree`` 用于分配和释放物理页。特别地，为了预防 double free 之类的 bug，我们每一次 free 以后会将页 ``memset`` 成 ``'U'`` ，alloc 以后会用 ``'N'`` 填充。

在 ``main`` 中编写测试代码，测试通过。

### 伙伴系统

构建一棵维护内核内存堆中物理页的线段树。

每个节点记录当前节点对应区域的最大连续页数。

每次分配与释放在线段树上遍历。

伙伴系统提供了``palloc(_n)``和``p_free``函数

### slab

将从伙伴系统中获取的整页地址进行合适拆分分配给内核。

具体实现是将页拆分成相同大小的内存段。

每次kalloc取对应大小的内

提供了``kmalloc`` 和 ``kfree``函数

## 虚拟内存

### 页表

#### SV39

通过类似树形的检索结构组织虚拟内存空间，通过三层页表形成一个动态的索引树。根索引目录下最多存放512个二级索引目录，每个二级目录下最多存放512个一级索引目录，每个一级索引目录下存放512个页表。

将虚拟地址划分为
1) [0..11] 页内偏移(page_offset)
2) [12..20] 0级索引
3) [21..29] 1级索引
4) [30..38] 2级索引

最大支持$1 * 2^{39} B = 512 GB$虚拟内存空间

### 系统虚拟内存划分

将UART,kernel,PLIC,PMEM的虚拟地址设置为与物理地址相同:避免因为在启用虚拟内存功能后，部分函数功能无法正常工作。

### RISCV的虚拟内存

如果所有虚拟内存映射都借助系统去实现“翻译”，那么开销将是无比巨大的。（每一次涉及到内存的操作都将发起系统调用）

RISCV借助``satp``寄存器辅助管理页表，实现在硬件层面对于虚拟内存的“翻译”。

硬件层面会使用tlb等缓存技术，提高虚拟内存“翻译”的效率。

为了使硬件能使用我们设置的页表，我们根据RISCV手册去存储页表和设置寄存器。

#### satp

satp的结构为
1) [0..43] PNN (根索引目录的物理地址)
2) [44..59] ASID (标识当前页表，使得机器能确认页表是否发生变化) (内核取MAX_PROCESS+1 其他为进程号+1。 为什么+1：riscv64对于ASID = 0有特殊处理)
3) [60..63] mode (页表模式 8 for SV39)

**注意** 

PNN的偏移值在satp中为0而在PTE中为10

$ PNN = PA >> 12 \ne PA  $

#### 索引页(pagetable)

大小4096 可以存储512个索引条目（PTE）

#### 索引条目(PTE)

SV39下PTE的结构为
1) [0..9] 状态VRWXUGAD
2) [9..52] PNN (索引目标的物理地址)

#### // sfence.vma

// sfence.vma zero, zero 可以刷新TLB

每次切换satp pmp寄存器前后需要刷新TLB

刷新TLB后内核正式启用虚拟内存。

### 虚拟内存启用后

例如palloc

palloc仍然是相同的代码，但palloc分配的不再是原来物理上的page（块），而是从虚拟内存的堆空间取出一个可用的page。

但依赖palloc的函数也能正常运行，因为他们也能“自动”通过页表“翻译”。

### vm

管理虚拟内存段的结构体

每个vm拥有一个pm_list

vm可以管理对应虚拟内存段在init, fork，exit，pagefault时的**行为**（如何初始化，如何拷贝，是否释放，如何处理缺页）

每个进程拥有一个vm_list

### 错误调试

1) 在mappages时，代码发生remmap(重复映射)。原因是pmem（堆空间）的对齐未合理实现，一个较好的实现方式是在链接脚本中添加``. = ALIGN(0x1000);``（页大小为4096）。
2) 在启用satp代码后内核立刻出现异常，并且异常处理程序也无法工作。经过排查后发现是未给予text段执行权限(PTE_X)。

## 附录

### kernel virtual memory space
|name|base|size|
|-|-|-|
|CLINT0          | 0x02000000|PG_SIZE|
|PLIC0           | 0x0c000000|PG_SIZE|
|VIRTIO          | 0x10001000|PG_SIZE|
|KERNEL0         | 0x80000000|内核代码大小|
|PMEM0           | KERNEL END|TO_MAX_PA|
|HEAP0           |0x100000000|0x80000000|
|CORO_STACK0(tid)|0x20000f000 + tid * 0x10000|最大PG_SIZE|
|STACK0          |0x300000000|0x80000000|
|TRAMPOLINE      |0x3fffff000|PG_SIZE|

### user virtual memory space
|name|base|size|
|-|-|-|
|CODE0           |0x00000000|用户代码大小|
|STACK0          |0x300000000|0x80000000|
|CORO_STACK0(tid)|0x20000f000 + tid * 0x10000|最大PG_SIZE|
|TRAMPOLINE      |0x3fffff000|PG_SIZE|