# Thread

## 执行流控制的单位

我们认为线程是执行流控制的单位，这样方便我们的代码编写。

我们注意到被调用者保存的寄存器是 ``ra`` ``sp`` 和 ``s[0:11]`` ，我们用一个结构来保存它。

进一步地，为了实现上下文的切换，我们实现 ``context_switch`` 函数。

``` asm
.globl context_switch
context_switch:
    sd ra, 0(a0)
    sd sp, 8(a0)
    sd s0, 16(a0)
    ...
    sd s11, 104(a0)

    ld ra, 0(a1)
    ld sp, 8(a1)
    ld s0, 16(a1)
    ...
    ld s11, 104(a1)
    
    ret // 在这里将返回到更改后的 sp
```

这样实现了上下文的切换。

# 进程

## 父进程与子进程

显然每个进程都需要存它的父进程。但它是否需要存它的子进程呢？

把一个进程的子进程都存下来有一些好处。例如，可以快速地遍历所有子进程。

// todo

## fork

在多线程结构中，``fork`` 理论上只会复制调用它的那个线程。（据说这是「POSIX 系统的历史包袱」）

或者说，我们不妨认为，多线程和子进程是不良兼容的，系统不保证你在多线程的过程中 fork 了一个子进程会发生什么。

## wait

关于 ``wait`` ，在多进程系统中存在一个严重的问题。具体来说，一个进程和它的子进程，谁先结束，谁先运行到 ``wait`` 函数处，是没有办法保证的。

父进程要如何知道子进程是否结束，我们调查到两种方案。

一种方案是，子进程在结束以后其资源仍不释放，直到父进程使用 ``wait`` 函数监听了它的释放；这样的问题是可能会出现僵尸进程。也就是父进程一直不释放子进程的资源。

另一种方案则是，在父进程处维护一个类似消息队列的东西，子进程似了以后给父进程发一个消息。这样的问题是给进程增加了额外的信息储存。 