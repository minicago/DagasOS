# Process & Thread

## Process

### 资源管理的单位

我们认为进程是资源管理的单位，这样方便我们分配资源。

在虚拟内存的分配方案见[1.5_memory_and_pages](1.5_memory_and_pages.md)

### 父进程与子进程

显然每个进程都需要存它的父进程。但它是否需要存它的子进程呢？

把一个进程的子进程都存下来有一些好处。例如，可以快速地遍历所有子进程。

但这样的空间开销也是不可忽视的，并且如果一个“关系”需要双向维护，那么保证“关系”的同步将会带来很大的代码实现难度。

所以目前阶段，我们只维护子进程记数。

### fork

在多线程结构中，``fork`` 理论上只会复制调用它的那个线程。（据说这是「POSIX 系统的历史包袱」）

或者说，我们不妨认为，多线程和子进程是不良兼容的，系统不保证你在多线程的过程中 fork 了一个子进程会发生什么。

### wait

关于 ``wait`` ，在多进程系统中存在一个严重的问题。具体来说，一个进程和它的子进程，谁先结束，谁先运行到 ``wait`` 函数处，是没有办法保证的。

父进程要如何知道子进程是否结束，我们调查到两种方案。

一种方案是，子进程在结束以后其资源仍不释放，直到父进程使用 ``wait`` 函数监听了它的释放；这样的问题是可能会出现僵尸进程。也就是父进程一直不释放子进程的资源。

另一种方案则是，在父进程处维护一个类似消息队列的东西，子进程似了以后给父进程发一个消息。这样的问题是给进程增加了额外的信息储存。 

## Thread

### 执行流控制的单位

我们认为线程是执行流控制的单位，这样方便我们控制代码运行。

我们考虑使用 ``scheduler_loop`` 去寻找一个处在就绪状态的thread然后运行之。即更换对应proc的页表，切换至用户程序的上下文，然后进入S态。

### why kernel coroutine? 

但当我们考虑到从用户程序返回后，内核即将切换thread时，我们发现此时内核只有可能处在中断处理程序，而我们无法获知在运行用户程序前 ``scheduler_loop`` 运行状态的信息，势必会导致潜在的内核内存泄漏问题（scheduler在系统栈中的数据无法正常销毁）。在学习xv6时，我们注意到xv6中存在的 ``switch_context`` 函数。根据反复研读代码，认真分析，我们发现xv6隐式地为每一个process实现了一个“协程”(coroutine)，这里我们称呼其为管理协程；而scheduler隶属于CPU，可以将其视为CPU的“主协程”（main coroutine）， xv6在”协程“间可以自由切换。

在我们的DagasOS中，我们编写了协程库coro.h，显式地将协程的切换逻辑表示出来。我们借鉴了C标准库中协程功能setjump和longjump功能的实现，根据setjump在切换前后返回值的不同，实现了switch_coro的功能，方便后续开发者理解和使用。这里我们将详细阐述，协程在进入用户程序前后的切换过程。

在进入用户态之前，系统首先需要从主协程切换到对应的管理协程，然后再进入用户程序。

那么，当从用户程序进入中断处理程序时，kernel仍然在运行管理携程，如果需要切换用户程序，则先切换至主协程，而主协程仍然接着上次切换前的状态继续运行，选择出下一个合适的线程。

当主协程再次选择上述的thread继续运行时，管理协程将会在上次中断处理函数中继续运行，而中断处理程序会经过 ``entry_to_user`` ，然后运行 ``trapret`` 最后回到用户程序。

而辅助协程可以随时创造和销毁，由主协程中管理其内存空间，可以避免内存泄漏。

``` mermaid

sequenceDiagram

participant A as scheduler_coro

participant B as thread_manager_coro

loop

Note left of A : select a ready thread to run 

A->>+B : run thread:tid

Note right of B : user program yeild or timer interrupt

B->>-A : sched

end
```

### 线程和进程的关系

一个进程上允许存在多个线程，他们之间**堆栈代码段资源完全相同**，这可能会导致线程之间的一些**非法**操作（如修改同一进程上其余线程的系统栈），但我们在系统层面上允许这种行为：综合考虑后，认为这种行为不具有较大的安全隐患，且用户可以避免并且在不了解系统的页表结构时很难触发。

进程会记录附着的线程数（但不知道具体tid：减小内存负担），当一个进程没有内存附着的时候，会允许其回收资源。

### 线程号

我们查阅资料发现两种线程标号的策略。
1) pid.tid型 即每个tid关于进程独立。
2) global tid型 即tid全局独立。

在这里我们选取后者，因为我们的进程没有保存其上的线程tid，选择1不利于tid编号。
