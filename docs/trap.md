# 中断和异常处理

## 目标

1) 能正常进入并退出处理程序。

## 步骤

1) start中实现将中断交给S-mode代理。

2) 在kernelvec中实现上下文的保存并进入处理程序。

3) 设置CSR，以进入stvec。

## S-mode代理

### CSR 寄存器

medeleg : 机器异常委托寄存器

mideleg : 机器中断委托寄存器

sie : S-mode下能处理的中断

## kernelvec

### kernelvec 为什么必须用RISCV64汇编实现？

因为正常的C函数会将函数地址压入系统栈，破坏context。

## 进入stvec

设置 csr 中 ``stvec`` 的值为我们的中断跳转程序。在这里，我们遇到了一个困扰我们一个半小时的严重问题，就是 ``stvec`` 总是无法写入。

我们尝试给他**随意**赋值（例如 ``0x999``）。然而，这样无论如何操作、在何处、以何种权限都无法成功写入。我们尝试了一些其他 csr 寄存器，有时可以写入，有时不行。

在尝试将 ``0x999`` 写入 ``sie`` 时，我们仍然遇到了失败。这是令人震惊的。然而，将 ``0x222`` 写入 ``sie`` 却是成功的。因此我们怀疑是否是写入的值的问题。

在这里我们尝试将 ``0xffff0000`` 写入 ``stvec`` 。令人震惊地，这居然成功了！我们立刻意识到，此前一直无法写入（转而会导致置零）的原因是，我们写入的值没有对 ``4`` 对齐，这使得我们本质上在修改一个 read-only 的部份。

我们修改我们的 .S ，在 stvec.S 的头部上加上：

``` asm
.align 4
```

于是可以正常修改 ``stvec`` 。