# 中断和异常处理

## 内核中断

### 目标

1) 能正常进入并退出处理程序。

2) 在处理程序中输出中断原因方便后续测试。

### 步骤

1) start中实现将中断交给S-mode代理(delegate)。
2) 在kernelvec中实现上下文的保存并进入处理程序。
3) 设置CSR，以进入stvec。

### S-mode代理

#### CSR 寄存器

medeleg : 机器异常委托寄存器

mideleg : 机器中断委托寄存器

sie : S-mode下能处理的中断

### kernelvec

#### kernelvec 为什么必须用RISCV64汇编实现？

因为正常的C函数会将函数地址压入系统栈，破坏上下文(context)。

### 进入stvec

设置 csr 中 ``stvec`` 的值为我们的中断跳转程序。在这里，我们遇到了一个困扰我们一个半小时的严重问题，就是 ``stvec`` 总是无法写入。

我们尝试给他**随意**赋值（例如 ``0x999``）。然而，这样无论如何操作、在何处、以何种权限都无法成功写入。我们尝试了一些其他 csr 寄存器，有时可以写入，有时不行。

在尝试将 ``0x999`` 写入 原本赋值为 ``0x222`` 的 ``sie`` 时，我们却发现 ``sie`` 变为 ``0x000``。这是令人震惊的。然后我们意识到在S态将 ``0x222`` 写入 ``sie`` 是成功的。因此我们怀疑是否是写入的值的问题。

在这里我们尝试将 ``0xffff0000`` 写入 ``stvec`` 令人震惊地，这居然成功了！我们立刻意识到，此前一直无法写入（转而会导致置零）的原因是，我们写入的值没有对 ``4`` 对齐，这使得我们本质上在修改一个 read-only 的部份。

我们修改我们的 .S ，在 stvec.S 的头部上加上：

``` asm
.align 4
```

于是可以正常修改 ``stvec`` 。

**注意** 以后在给CSR寄存器赋值是要注意是否可能因为给保留位赋值导致 W_CSR 失败，这种失败**可能不会引发异常**。

## 设备中断

### 时钟

#### CLINT（Core Local Interrupt）

管理内部的中断，软件中断和计时器中断。

#### 时钟的初始设置

```c
#define CLINT_MTIMECMP (CLINT0 + 0x4000)
#define CLINT_MTIME (CLINT0 + 0xBFF8) // cycles since boot.
```

时钟在第 $MTIMECMP$ 周期触发

#### 时钟中断处理

1) 首先预留五个uint64的空间来处理重置时钟的工作（[0..2]暂存寄存器，[3]存储上次触发时间，[4]存储间隔时间）
2) 用CSR寄存器mscratch保存上述空间的地址。
3) 触发中断时先保存寄存器
4) 将当前时间赋值给上次触发时间。
5) 当中断出现将上次触发时间加上间隔作为新的触发时间。
6) 将对应信息写入CLINT中的对应寄存器
7) 引发S-mode的2号中断处理程序
8) 恢复现场
9) mret



